import "dotenv/config";
import * as Sentry from "@sentry/node";
import { RewriteFrames } from "@sentry/integrations";
import { writeJson, mkdirp, remove } from "fs-extra";
import { join } from "path";
import { default as SDKWrapper } from "./lib/sdk";
import { default as FileWriter } from "./lib/file";
import { default as log } from "./lib/log";
import { SENTRY_DSN } from "./lib/constants";
// @ts-ignore
import pkg from "./package.json";

declare global {
  namespace NodeJS {
    interface Global {
      __rootdir__: string;
    }
  }
}

global.__rootdir__ = __dirname || process.cwd();

Sentry.init({
  dsn: SENTRY_DSN,
  release: `${pkg.name}@${pkg.version}`,
  integrations: [new RewriteFrames({ root: global.__rootdir__ })],
  beforeSend(event): Sentry.Event {
    if (event.user.email) {
      delete event.user.email;
    }
    return event;
  }
});

interface Paths {
  readonly outputPath: string;
  readonly intentPath: string;
  readonly entityPath: string;
}

/**
 * Removes and then creates directories that hold files
 * @param paths object containing paths to directories that will hold files
 * generated by the script
 * @returns Promise<void>
 */
async function recreateOutputDirectories(paths: Paths): Promise<void> {
  const { outputPath, intentPath, entityPath } = paths;
  await remove(outputPath);
  await mkdirp(intentPath);
  await mkdirp(entityPath);
}

async function main(args: string[]): Promise<void> {
  const DEFAULT_OUTPUT = "output";
  let [, , outputDirectory] = args;
  if (typeof outputDirectory === "undefined") {
    outputDirectory = process.env.OUTPUT_DIR || DEFAULT_OUTPUT;
  }
  const INTENT_PATH = join(outputDirectory, "intents");
  const ENTITY_PATH = join(outputDirectory, "entities");
  log("creating output directories");
  await recreateOutputDirectories({
    outputPath: outputDirectory,
    intentPath: INTENT_PATH,
    entityPath: ENTITY_PATH
  });
  log("fetching project data");
  const date = Date.now();
  const { timestamp, data: projectData } = await new SDKWrapper({
    token: process.env.BOTMOCK_TOKEN, 
    teamId: process.env.BOTMOCK_TEAM_ID,
    projectId: process.env.BOTMOCK_PROJECT_ID,
    boardId: process.env.BOTMOCK_BOARD_ID,
  }).fetch();
  log(`fetched project data in ${timestamp - date}ms`);
  log("writing files");
  await new FileWriter({ outputDirectory, projectData }).write();
  log("done");
}

process.on("unhandledRejection", () => {});
process.on("uncaughtException", () => {});

main(process.argv).catch(async (err: Error) => {
  log(err.stack, { hasError: true });
  if (process.env.OPT_IN_ERROR_REPORTING) {
    Sentry.captureException(err);
  } else {
    const { message, stack } = err;
    await writeJson(join(__dirname, "err.json"), { message, stack });
  }
});

// let semaphore: void | Sema;
// let shouldUseDefaultWelcomeIntent = true;
// const INTENT_NAME_DELIMITER = process.env.INTENT_NAME_DELIMITER || "-";
// const INTENT_PATH = path.join(outputPath, "intents");
// const ENTITY_PATH = path.join(outputPath, "entities");

// try {
//   (async () => {
//     const defaultIntent = {
//       name: "welcome",
//       updated_at: Date.now(),
//       // merge in utterances of default dialogflow welcome intent
//       utterances: JSON.parse(
//         await readFile(
//           path.join(
//             "templates",
//             "defaults",
//             "Default Welcome Intent_usersays_en.json"
//           ),
//           "utf8"
//         )
//       ).map((utterance: any) => {
//         const [{ text }] = utterance.data;
//         return { text, variables: [] };
//       }),
//     };
//     // recreate output directories
//     // await remove(outputPath);
//     // await util.promisify(mkdirp)(INTENT_PATH);
//     // await util.promisify(mkdirp)(ENTITY_PATH);
//     // fetch project data via the botmock api
//     const project: Assets.ProjectResponse = await getProjectData({
//       projectId: process.env.BOTMOCK_PROJECT_ID,
//       boardId: process.env.BOTMOCK_BOARD_ID,
//       teamId: process.env.BOTMOCK_TEAM_ID,
//       token: process.env.BOTMOCK_TOKEN,
//     });
//     let [intents, entities, board, variables, { platform, name: projectName }] = project.data;
//     if (platform === "google-actions") {
//       platform = "google";
//     }
//     // create mapping of message id, intent ids connected to it
//     const intentMap = createIntentMap(board.messages, intents);
//     const explorer = new BoardExplorer({ board, intentMap });
//     // create function that groups messages not connected by any intent
//     const collectIntermediateMessages: any = createMessageCollector(
//       intentMap,
//       explorer.getMessageFromId.bind(explorer)
//     );
//     // get the name of an intent from its id
//     const getIntentName = (id: string): string => {
//       const intent: Assets.Intent = intents.find(intent => intent.id === id) || {};
//       return intent.name || "";
//     };
//     // find the input context implied by a given message id
//     const getInputContextFromMessage = (
//       immediateMessageId: string
//     ): Assets.InputContext => {
//       const context: string[] = [];
//       const seenIds: string[] = [];
//       // recurse on a message id to fill in context
//       (function unwindFromMessageId(messageId: string): void {
//         const { previous_message_ids } = explorer.getMessageFromId(messageId);
//         let messageFollowingIntent;
//         if (
//           (messageFollowingIntent = previous_message_ids.find(
//             ({ message_id }) => intentMap.get(message_id)
//           ))
//         ) {
//           const intentName = getIntentName(
//             intentMap.get(messageFollowingIntent.message_id)[0]
//           );
//           if (typeof intentName !== "undefined") {
//             context.push(intentName);
//           }
//         } else {
//           for (const { message_id } of previous_message_ids) {
//             if (!seenIds.includes(messageId)) {
//               seenIds.push(messageId);
//               unwindFromMessageId(messageId);
//             }
//           }
//         }
//       })(immediateMessageId);
//       return context;
//     };
//     const uniqueNameMap = new Map<string, number>();
//     // construct intent file name based on project name and input context
//     const getIntentFileBasename = (
//       contexts: Assets.InputContext,
//       messageName: string
//     ): string => {
//       let str =
//         projectName.slice(0, 10) +
//         (contexts.length ? INTENT_NAME_DELIMITER : "") +
//         contexts.join(INTENT_NAME_DELIMITER) +
//         INTENT_NAME_DELIMITER +
//         messageName;
//       if (uniqueNameMap.get(messageName)) {
//         const i = str.lastIndexOf(INTENT_NAME_DELIMITER);
//         str =
//           str.slice(0, i) +
//           INTENT_NAME_DELIMITER +
//           messageName +
//           uniqueNameMap.get(messageName);
//         uniqueNameMap.set(messageName, uniqueNameMap.get(messageName) + 1);
//       } else {
//         uniqueNameMap.set(messageName, 1);
//       }
//       return str.toLowerCase().replace(/\s/gi, INTENT_NAME_DELIMITER);
//     };
//     // map a message to proper output context object
//     const createOutputContextFromMessage = (
//       message: Assets.Message
//     ): Assets.OutputContext => ({
//       name: getIntentName(message.intent.value),
//       parameters: {},
//       lifespan: 1,
//     });
//     // pair output context of those intermediate messages that create
//     // intents with those next messages that directly follow intents
//     const getAffectedContexts = (
//       intermediateMessages: Assets.Message[],
//       nextMessageIds: any[]
//     ): Assets.OutputContext[] => [
//       ...intermediateMessages.reduce((acc, { next_message_ids = [] }) => {
//         if (!next_message_ids.length) {
//           return acc;
//         }
//         return [
//           ...acc,
//           ...next_message_ids
//             .filter(
//               nextMessage =>
//                 !!intents.find(intent => intent.id === nextMessage.intent.value)
//             )
//             .map(createOutputContextFromMessage),
//         ];
//       }, []),
//       ...nextMessageIds
//         .filter(
//           nextMessage =>
//             typeof nextMessage.intent !== "string" && nextMessage.intent.value
//         )
//         .map(createOutputContextFromMessage),
//     ];
//     if (intentMap.size / board.messages.length <= 0.2) {
//       log(
//         "found few intents in flow; create more intents to ensure better functionality"
//       );
//     }
//     // if no intent from the root is defined set a welcome-like intent
//     if (!intentMap.size || explorer.isMissingWelcomeIntent(board.messages)) {
//       log("auto-generating welcome intent");
//       const { next_message_ids } = board.messages.find(
//         explorer.messageIsRoot.bind(explorer)
//       );
//       const [{ message_id: firstNodeId }] = next_message_ids;
//       intentMap.set(firstNodeId, [uuid()]);
//       shouldUseDefaultWelcomeIntent = false;
//     }
//     // create instance of semaphore class to control write concurrency
//     semaphore = new Sema(os.cpus().length, { capacity: intentMap.size || 1 });
//     // create instance of response writing class
//     const provider = new Provider(platform);
//     // for each intent-message, iterate over intents connected to this message and write files
//     for (const [messageId, intentIds] of intentMap.entries()) {
//       const {
//         message_type,
//         payload,
//         message_id,
//         next_message_ids,
//         // previous_message_ids,
//       } = explorer.getMessageFromId(messageId);
//       for (const connectedIntentId of intentIds) {
//         await semaphore.acquire();
//         try {
//           let name = getIntentName(connectedIntentId);
//           if (typeof name === "undefined") {
//             const uniqueName = uuid();
//             log(
//               `${os.EOL}found unnamed intent. ${os.EOL}using name ${uniqueName}${os.EOL}`
//             );
//             name = uniqueName;
//           }
//           const contexts = [
//             ...getInputContextFromMessage(messageId),
//             ...(typeof name !== "undefined" ? [name] : []),
//           ];
//           const basename = truncateBasename(
//             getIntentFileBasename(contexts, payload.nodeName)
//           );
//           const filePath = path.join(INTENT_PATH, `${basename}.json`);
//           const intermediateMessages = collectIntermediateMessages(
//             next_message_ids
//           ).map(explorer.getMessageFromId.bind(explorer));
//           // affectedContexts should be the union of input contexts and any
//           // intents reachable from messages in the intermediate cluster
//           const affectedContexts = [
//             ...contexts.map(name => ({ name, parameters: {}, lifespan: 1 })),
//             ...getAffectedContexts(intermediateMessages, next_message_ids),
//           ];
//           const { utterances, updated_at, slots }: Partial<Assets.Intent> =
//             intents.find(intent => intent.id === connectedIntentId) ||
//             defaultIntent;
//           const uniqueVariables = getUniqueVariablesInUtterances(utterances).map(variableName => (
//             variables.find((variable: any) => variable.name === variableName)
//           ));
//           // TODO: should use dynamic entity name
//           const DATA_TYPE = "@sys.any";
//           const LANG = "en";
//           await writeUtterancesFile(filePath, utterances, updated_at, entities);
//           await writeFile(
//             filePath,
//             JSON.stringify(
//               {
//                 ...templates.intent,
//                 id: uuid(),
//                 name: basename,
//                 contexts: explorer.hasWelcomeIntent(message_id) ? [] : contexts,
//                 events: explorer.hasWelcomeIntent(messageId)
//                   ? [{ name: "WELCOME" }]
//                   : [],
//                 lastUpdate: Date.parse(updated_at.date),
//                 responses: [
//                   {
//                     action: uniqueVariables.length ? `action.${uniqueVariables[0].name}` : "",
//                     parameters: !Array.isArray(slots) ? [] : slots.map((slot: Assets.Slot) => {
//                       const { name } = variables.find(variable => variable.id === slot.variable_id);
//                       return {
//                         id: slot.id,
//                         name,
//                         required: slot.is_required,
//                         dataType: DATA_TYPE,
//                         value: `$${name}`,
//                         promptMessages: Array.of({ lang: LANG, value: slot.prompt}),
//                       }
//                     }),
//                     speech: [],
//                     resetContexts: false,
//                     affectedContexts,
//                     defaultResponsePlatforms: supportedPlatforms.has(
//                       platform.toLowerCase()
//                     )
//                       ? { [platform.toLowerCase()]: true }
//                       : {},
//                     messages: [
//                       { message_type, payload },
//                       ...intermediateMessages,
//                     ]
//                       .map(message => ({
//                         ...message,
//                         payload: {
//                           ...message.payload,
//                           text: replaceVariableSignInText(message.payload.text),
//                         },
//                       }))
//                       .map(message =>
//                         provider.create(message.message_type, message.payload)
//                       ),
//                   },
//                 ],
//               },
//               null,
//               2
//             ) + os.EOL
//           );
//         } catch (err) {
//           if (semaphore.nrWaiting()) {
//             await semaphore.drain();
//           }
//           throw err;
//         } finally {
//           semaphore.release();
//         }
//       }
//     }
//     // write an entity file for each entity in the project
//     for (const entity of entities) {
//       await writeFile(
//         path.join(ENTITY_PATH, `${entity.name}.json`),
//         JSON.stringify(
//           {
//             ...templates.entity,
//             id: uuid(),
//             name: entity.name,
//           },
//           null,
//           2
//         ) + os.EOL
//       );
//       await writeFile(
//         path.join(ENTITY_PATH, `${entity.name}_entries_en.json`),
//         JSON.stringify(entity.data, null, 2) + os.EOL
//       );
//     }
//     // copy templates over to the output destination
//     for (const filename of await readdir(
//       path.join(__dirname, "templates")
//     )) {
//       const pathToContent = path.join(__dirname, "templates", filename);
//       const stats: any = await stat(pathToContent);
//       // if this content of the templates directory is not itself a directory,
//       // possibly copy the file over into the output directory
//       if (!stats.isDirectory()) {
//         if (filename.startsWith("intent") || filename.startsWith("entity")) {
//           continue;
//         }
//         await copyFileToOutput(pathToContent);
//       } else {
//         // assume these are the templates for the default intents; copy them
//         // into the intents directory
//         for (const file of await readdir(pathToContent)) {
//           if (!shouldUseDefaultWelcomeIntent && file.includes("Welcome")) {
//             continue;
//           }
//           await copyFileToOutput(path.join(pathToContent, file), {
//             isIntentFile: true,
//           });
//         }
//       }
//     }
//     let sum: number = 0;
//     // calculate uncompressed output file size
//     for (const content of await readdir(outputPath)) {
//       const pathTo = path.join(outputPath, content);
//       const stats = await stat(pathTo);
//       if (stats.isFile()) {
//         sum += stats.size;
//       } else if (stats.isDirectory()) {
//         // for each file in this directory, find its size and add it to the total
//         for (const file of (await readdir(pathTo)).filter(
//           async (dirContent: any) =>
//             (await stat(path.join(pathTo, dirContent))).isFile()
//         )) {
//           sum += (await stat(path.join(pathTo, file))).size;
//         }
//       }
//     }
//     console.info(
//       `done.${os.EOL}wrote ${sum / 1000}kB to ${__dirname}${
//         path.sep
//       }${path.basename(outputPath)}.`
//     );
//   })();
// } catch (err) {
//   console.error(err);
//   process.exit(1);
// }
